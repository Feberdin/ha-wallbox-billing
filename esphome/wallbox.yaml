esphome:
  name: esp32-wallbox
  friendly_name: ESP32-WallBox

  on_boot:
    priority: 600
    then:
      - lambda: |-
          // Falls gespeicherter Wert NaN/Inf ist → auf Startwert setzen
          if (std::isnan(id(wallbox_energy_kwh)) || std::isinf(id(wallbox_energy_kwh))) {
            id(wallbox_energy_kwh) = 2775.01f;
          }

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: "nsEOmUr9Tj2Kbr5lEcOT5W+/5UICecUXTH2Biv6WJt0="
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: "7fd058d4a57f07a21896069e28ff49ae"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Esp32-Wallbox Fallback Hotspot"
    password: "C6h25fkvdWYj"

captive_portal:

web_server:
  port: 80

# Persistenter kWh-Zähler im Flash
globals:
  - id: wallbox_energy_kwh
    type: float
    restore_value: true
    initial_value: "2775.01"

# ====== Editierbare Felder in Home Assistant (als Eingabefeld statt Slider) ======
number:
  # 1) Startwert setzen (überschreibt wallbox_energy_kwh dauerhaft)
  - platform: template
    name: "Wallbox Zählerstand setzen"
    id: wallbox_set_kwh
    unit_of_measurement: "kWh"
    min_value: 0
    max_value: 1000000
    step: 0.001
    mode: box
    optimistic: true
    restore_value: true
    initial_value: 2775.01
    set_action:
      - lambda: |-
          id(wallbox_energy_kwh) = (float)x;
      - component.update: wallbox_energy_total

  # 2) Offset-Korrektur (addiert/subtrahiert einmalig)
  - platform: template
    name: "Wallbox Zählerstand Offset"
    id: wallbox_offset_kwh
    unit_of_measurement: "kWh"
    min_value: -10000
    max_value: 10000
    step: 0.001
    mode: box
    optimistic: true
    restore_value: true
    initial_value: 0
    set_action:
      - lambda: |-
          id(wallbox_energy_kwh) += (float)x;
          // Offset wieder auf 0 zurücksetzen, damit es "einmalig" wirkt
          id(wallbox_offset_kwh).publish_state(0);
      - component.update: wallbox_energy_total

sensor:
  # S0 Impulsrate (imp/min) -> daraus Leistung (W) berechnen
  - platform: pulse_counter
    pin:
      number: GPIO14
      mode:
        input: true
        pullup: true
      inverted: true

    name: "Wallbox Leistung"
    id: wallbox_power
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    update_interval: 10s
    internal_filter: 13us
    accuracy_decimals: 0

    filters:
      - throttle_average: 30s
      - lambda: |-
          if (x < 1.0) return 0.0;
          return x;
      # Annahme: 1000 imp/kWh -> W = (imp/min) * 60
      - multiply: 60.0

  # Zählerstand aus Global (wird auch im Webinterface angezeigt)
  - platform: template
    name: "Wallbox Zählerstand"
    id: wallbox_energy_total
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 3
    update_interval: 10s
    lambda: |-
      return id(wallbox_energy_kwh);

# Energie fortschreiben: aus Leistung (W) + Zeit delta -> kWh addieren
interval:
  - interval: 10s
    then:
      - lambda: |-
          const float p = id(wallbox_power).state;
          if (std::isnan(p) || std::isinf(p)) return;

          const float dt_hours = 10.0f / 3600.0f;
          id(wallbox_energy_kwh) += (p * dt_hours) / 1000.0f;
